import copy
import logging
import os
import re
from contextlib import suppress
from chemsmart.jobs.settings import MolecularJobSettings
from chemsmart.io.gaussian.gengenecp import GenGenECPSection
from chemsmart.utils.periodictable import PeriodicTable

pt = PeriodicTable()

from pyatoms.io.ase.atoms import AtomsWrapper
from pyatoms.io.gaussian import GaussianRefs
from pyatoms.jobs.settings import read_molecular_job_yaml
from pyatoms.utils.utils import (
    file_cache,
    get_prepend_string_list_from_modred_free_format,
)

gaussian_ab_initio = GaussianRefs().gaussian_ab_initio
gaussian_functionals = GaussianRefs().gaussian_dft_fuctionals
gaussian_bases = GaussianRefs().gaussian_basis_sets
gaussian_solvation_models = GaussianRefs().gaussian_solvation_models
gassian_additional_route_parameters = (
    GaussianRefs().gaussian_additional_route_parameters
)

logger = logging.getLogger(__name__)


class GaussianJobSettings(MolecularJobSettings):
    def __init__(
        self,
        ab_initio=None,
        functional=None,
        basis=None,
        charge=None,
        multiplicity=None,
        chk=True,
        job_type=None,
        title=None,
        freq=False,
        numfreq=False,
        dieze_tag=None,
        solvent_model=None,
        solvent_id=None,
        additional_opt_options_in_route=None,
        additional_route_parameters=None,
        route_to_be_written=None,
        modredundant=None,
        gen_genecp_file=None,
        heavy_elements=None,
        heavy_elements_basis=None,
        light_elements_basis=None,
        custom_solvent=None,
        append_additional_info=None,
        forces=False,
        **kwargs,
    ):
        super().__init__(
            ab_initio=ab_initio,
            functional=functional,
            basis=basis,
            charge=charge,
            multiplicity=multiplicity,
            freq=freq,
            numfreq=numfreq,
            job_type=job_type,
            solvent_model=solvent_model,
            solvent_id=solvent_id,
            additional_route_parameters=additional_route_parameters,
            route_to_be_written=route_to_be_written,
            modredundant=modredundant,
            gen_genecp_file=gen_genecp_file,
            heavy_elements=heavy_elements,
            heavy_elements_basis=heavy_elements_basis,
            light_elements_basis=light_elements_basis,
            custom_solvent=custom_solvent,
            forces=forces,
            **kwargs,
        )
        self.chk = chk
        self.title = title
        self.dieze_tag = dieze_tag
        self.additional_opt_options_in_route = additional_opt_options_in_route
        self.append_additional_info = append_additional_info

        if gen_genecp_file is not None and "~" in gen_genecp_file:
            gen_genecp_file = os.path.expanduser(gen_genecp_file)
        self.gen_genecp_file = gen_genecp_file

        if append_additional_info is None:
            append_additional_info = ""
        self.append_additional_info = append_additional_info

        if forces is True and freq is True:
            raise ValueError(
                "Frequency and Force calculations cannot be performed by Gaussian at the same time!\n"
                'Such an input file will give "Illegal IType or MSType generated by parse." error.'
            )

    def merge(
        self, other, keywords=("charge", "multiplicity"), merge_all=False
    ):
        """Overwrite self settings with other settings.

        Args:
            keywords (list): Specific list of keywords to merge.
                Defaults to charge and multiplicity.
                If None, all settings will be merged (Caution: may cause issue if e.g.,
                genecp log file used to prepare input without genecp).
            other (JobSettings, dict): Settings to merge. Can also take the form of a dictionary
            merge_all (bool): If True, merge all settings. If False, only merge the settings specified in keywords.
        """
        other_dict = other if isinstance(other, dict) else other.__dict__

        if merge_all:
            # Update self with other for all
            merged_dict = self.__dict__.copy()
            merged_dict.update(other_dict)
            return type(self)(**merged_dict)

        if keywords is not None:
            other_dict = {
                k: other_dict[k] for k in keywords if k in other_dict
            }
        # Update self with other
        merged_dict = self.__dict__.copy()
        merged_dict.update(other_dict)
        return type(self)(**merged_dict)

    def copy(self):
        return copy.deepcopy(self)

    def __getitem__(self, key):
        return self.__dict__[key]

    def __eq__(self, other):
        """Two settings objects are equal if all their attributes are equal."""
        if type(self) is not type(other):
            return NotImplemented

        # Exclude append_additional_info from the comparison
        self_dict = self.__dict__
        self_dict.pop("append_additional_info")

        other_dict = other.__dict__
        other_dict.pop("append_additional_info")

        is_equal = self_dict == other_dict
        if not is_equal:
            import dictdiffer

            logger.info("Gaussian job settings are not equal.")
            for diff in list(dictdiffer.diff(self_dict, other_dict)):
                logger.info(f"Difference: {diff}")
        return self_dict == other_dict

    @classmethod
    def from_comfile(cls, filename):
        """Return Gaussian settings object from a given gaussian.com file.

        Args:
            filename (str): file path of the .com file string to be supplied.
        """
        from chemsmart.io.gaussian.input import Gaussian16Input

        com_path = os.path.abspath(filename)
        logger.info(f"Return Settings object from .com filename: {filename}")
        gaussian_settings_from_comfile = Gaussian16Input(
            filename=filename
        ).read_settings()
        logger.info(
            f"with settings: {gaussian_settings_from_comfile.__dict__}"
        )
        return gaussian_settings_from_comfile

    @classmethod
    def from_inpfile(cls, filename):
        """Return Gaussian settings object from a given orca.inp file.

        Args:
            filename (str): file path of the .inp file string to be supplied.
        """
        from chemsmart.io.orca.input import ORCAInput

        inp_path = os.path.abspath(filename)
        logger.info(f"Return Settings object from inp file: {inp_path}")
        orca_settings_from_inpfile = ORCAInput(
            filename=inp_path
        ).read_settings()
        gaussian_default_settings = cls.default()
        gaussian_settings_from_inpfile = gaussian_default_settings.merge(
            orca_settings_from_inpfile, merge_all=True
        )
        logger.info(
            f"with settings: {gaussian_settings_from_inpfile.__dict__}"
        )
        return gaussian_settings_from_inpfile

    @classmethod
    def from_logfile(cls, filename):
        """Return Gaussian settings object from a given gaussian.log file.

        Args:
            filename (str): file path of the .log file to be supplied.
            kwargs (dict): additional keyword arguments to be supplied to Gaussian16Output.
        """
        log_path = os.path.abspath(filename)
        from chemsmart.io.gaussian.output import (
            Gaussian16Output,
            Gaussian16OutputWithPBC,
        )

        logger.info(f"Return Settings object from logfile: {log_path}")
        try:
            settings = Gaussian16Output(filename=log_path).read_settings()
        except ValueError:
            settings = Gaussian16OutputWithPBC(
                filename=log_path
            ).read_settings()

        return settings

    @classmethod
    def from_outfile(cls, filename):
        """Return Gaussian job settings from ORCA output file."""
        from chemsmart.io.orca.output import ORCAOutput

        out_path = os.path.abspath(filename)
        logger.info(
            f"Return Settings object from ORCA .out filename: {out_path}"
        )
        orca_settings_from_outfile = ORCAOutput(
            filename=out_path
        ).read_settings()
        gaussian_default_settings = cls.default()
        gaussian_settings_from_outfile = gaussian_default_settings.merge(
            orca_settings_from_outfile, merge_all=True
        )
        logger.info(
            f"with settings: {gaussian_settings_from_outfile.__dict__}"
        )
        return gaussian_settings_from_outfile

    @classmethod
    def default(cls):
        return cls(
            ab_initio=None,
            functional=None,
            basis=None,
            charge=None,
            multiplicity=None,
            chk=True,
            job_type=None,
            title="Gaussian job with default settings",
            freq=False,
            numfreq=False,
            dieze_tag=None,
            solvent_model=None,
            solvent_id=None,
            additional_opt_options_in_route=None,
            additional_route_parameters=None,
            route_to_be_written=None,
            modredundant=None,
            gen_genecp_file=None,
            heavy_elements=None,
            heavy_elements_basis=None,
            light_elements_basis=None,
            custom_solvent=None,
            append_additional_info=None,
            forces=False,
        )

    @classmethod
    def from_filepath(cls, filepath, **kwargs):
        if filepath.endswith((".com", ".gjf")):
            return cls.from_comfile(filepath)
        if filepath.endswith(".inp"):
            return cls.from_inpfile(filepath)
        if filepath.endswith(".log"):
            return cls.from_logfile(filepath, **kwargs)
        raise ValueError(f"Could not create {cls} from {filepath}")

    @property
    def route_string(self):
        if self.route_to_be_written is not None:
            route_string = self._get_route_string_from_user_input()
        else:
            route_string = self._get_route_string_from_jobtype()
        return route_string

    def _get_route_string_from_user_input(self):
        route_string = self.route_to_be_written
        if not route_string.startswith("#"):
            route_string = (
                f"#{self.dieze_tag} {route_string}"
                if self.dieze_tag is not None
                else f"# {route_string}"
            )
        return route_string

    def get_light_elements(self, molecule):
        if self.heavy_elements is None:
            return None

        unique_atoms = set(molecule.chemical_symbols)
        light_elements_set = unique_atoms - set(self.heavy_elements)
        light_elements_list = list(light_elements_set)

        sorted_light_elements_list = pt.sorted_periodic_table_list(
            light_elements_list
        )
        logger.info(
            f"Light elements in structure: {sorted_light_elements_list}"
        )
        return sorted_light_elements_list

    def _get_route_string_from_jobtype(self):  # noqa: PLR0912, PLR0915
        route_string = ""
        if self.dieze_tag is not None:
            route_string += (
                f"#{self.dieze_tag}"  # e.g. dieze_tag='p' to get '#p'
            )
        else:
            route_string += "#"

        # write opt with additional options e.g., maxstep, calcall etc
        if self.additional_opt_options_in_route is not None:
            if self.job_type == "opt":
                route_string += (
                    f" opt=({self.additional_opt_options_in_route})"
                )
            elif self.job_type == "ts":
                if "calcall" not in self.additional_opt_options_in_route:
                    route_string += f" opt=(ts,calcfc,noeigentest,{self.additional_opt_options_in_route})"
                else:
                    route_string += f" opt=(ts,noeigentest,{self.additional_opt_options_in_route})"
            elif self.job_type == "modred":
                route_string += f" opt=(modredundant,{self.additional_opt_options_in_route})"
                self.freq = True
            elif self.job_type == "scan":
                route_string += f" opt=(modredundant,{self.additional_opt_options_in_route})"
                self.freq = False
            elif self.job_type == "sp":
                route_string += ""
        elif self.additional_opt_options_in_route is None:
            if self.job_type == "opt":
                route_string += " opt"
            elif self.job_type == "ts":
                route_string += " opt=(ts,calcfc,noeigentest)"
            elif self.job_type == "modred":
                route_string += " opt=modredundant"
                self.freq = True
            elif self.job_type == "scan":
                route_string += " opt=modredundant"
                self.freq = False
            elif self.job_type == "sp":
                route_string += ""

        # write frequency
        if self.freq and not self.numfreq:
            route_string += " freq"
        elif not self.freq and self.numfreq:
            route_string += " freq=numer"

        # write functional and basis
        if self.basis is None:
            raise ValueError("Warning: Basis is missing!")
        if self.ab_initio is not None and self.functional is None:
            method = self.ab_initio
        elif self.ab_initio is None and self.functional is not None:
            method = self.functional
        elif self.ab_initio is not None and self.functional is not None:
            raise ValueError(
                "Warning: Both ab initio and DFT functional are provided!"
            )
        else:
            raise ValueError(
                "Warning: Both ab initio and DFT functional are missing!"
            )

        # write basis set
        route_string += f" {method} {self.basis}"

        # write forces calculation
        if self.forces:
            route_string += " force"

        if self.custom_solvent is not None:
            if self.solvent_model is None and self.solvent_id is None:
                route_string += (
                    " scrf=(pcm,read)"  # using pcm model as default
                )
            else:
                # Set default values if any of solvent_model or solvent_id are None
                solvent_model = self.solvent_model or "pcm"
                solvent_id = self.solvent_id or "generic,read"
                route_string += f" scrf=({solvent_model},solvent={solvent_id})"
        elif (
            self.solvent_model is not None and self.solvent_id is not None
        ):  # solvation is turned on
            route_string += (
                f" scrf=({self.solvent_model},solvent={self.solvent_id})"
            )
        elif (self.solvent_model is not None and self.solvent_id is None) or (
            self.solvent_model is None and self.solvent_id is not None
        ):  # if one is provided but the other not
            raise ValueError(
                f"Both solvent model and solvent ID need to be specified.\n"
                f"Currently, solvent model is {self.solvent_model} and solvent id is {self.solvent_id}!"
            )

        # write additional parameters for route
        if self.additional_route_parameters is not None:
            route_string += f" {self.additional_route_parameters}"

        # write job type specific route
        if self.job_type == "nci":
            route_string += " output=wfn"  # output wavefunction file for NCI
        elif self.job_type == "wbi":
            route_string += " pop=nboread"  # write bond order matrix
        return route_string

    def write_gaussian_input_from_job(self, job, jobrunner, **kwargs):
        num_cores_per_node = jobrunner.server.NUM_CORES
        num_cores = jobrunner.num_nodes * num_cores_per_node
        mem_gigs = min(int(jobrunner.server.MAX_MEM_GIGS // 2), 2 * num_cores)
        return self.write_gaussian_input(
            atoms=job.atoms,
            job_label=job.label,
            num_cores=num_cores,
            mem_gigs=mem_gigs,
            **kwargs,
        )

    def write_gaussian_input(
        self,
        atoms,
        job_label=None,
        num_cores=20,
        mem_gigs=20,
        output_dir=None,
        make_dir_if_not_present=True,
    ):
        """Write Gaussian input file.

        Args:
            atoms: atoms object containing the structure.
            job_label: job basename to be used.
            num_cores: number of cores from server for Gaussian input.
            mem_gigs: memory in GB for Gaussian input.
            output_dir: output directory for input file writing.
            make_dir_if_not_present: make directory if it is not present

        Return:
            filepath of the inputfile that is written.
        """
        logger.info(
            f"Writing gaussian input file with settings: {self.__dict__}"
        )

        if output_dir is None:
            output_dir = "."

        if not os.path.isdir(output_dir) and make_dir_if_not_present:
            os.mkdir(output_dir)

        # get basename/job_label for inputs/outputs writing
        assert (
            job_label is not None
        ), f"Basename of Gaussian file to be written {job_label} cannot be None!"

        atoms = AtomsWrapper.from_atoms(atoms)
        input_filename = job_label + ".com"
        filepath = os.path.join(output_dir, input_filename)
        logger.info(f"Writing inputfile {filepath} to folder {output_dir}\n")
        with open(filepath, "w") as f:  # will close() when we leave this block
            self._write_gaussian_header(
                f=f,
                num_cores=num_cores,
                mem_gigs=mem_gigs,
                job_label=job_label,
            )
            self._write_route_section(f, atoms)
            self._write_gaussian_title(f, job_label)
            self._write_charge_and_multiplicity(f)
            self._write_cartesian_coordinates(f, atoms)
            self._write_pbc(f, atoms)
            self._append_modredundant(f)  # write modredundant parameters
            self._append_gen_genecp_basis(f, atoms)  # then write genecp info
            self._append_custom_solvent_parameters(
                f
            )  # followed by user defined solvennt parameters
            self._append_job_specific_info(f, job_label)
            self._append_other_additional_info(f)
            self._write_link_section(f, atoms, num_cores, mem_gigs, job_label)
        return filepath

    def _write_gaussian_header(self, f, num_cores, mem_gigs, job_label):
        if self.chk:
            f.write(f"%chk={job_label}.chk\n")
        f.write(f"%nprocshared={num_cores}\n")
        f.write(f"%mem={mem_gigs}GB\n")

    def _write_route_section(self, f, atoms):
        if self.route_to_be_written is not None:
            self._write_route_section_from_user_input(f)
        else:
            self._write_route_section_default(f, atoms=atoms)

    def _write_route_section_default(self, f, atoms):
        route_string = self._get_route_string_from_jobtype(atoms=atoms)
        f.write(route_string + "\n")
        f.write("\n")

    def _get_route_string_from_jobtype(self, atoms):  # noqa: PLR0912, PLR0915
        route_string = ""
        if self.dieze_tag is not None:
            route_string += (
                f"#{self.dieze_tag}"  # e.g. dieze_tag='p' to get '#p'
            )
        else:
            route_string += "#"

        # write opt with additional options e.g., maxstep, calcall etc
        if self.additional_opt_options_in_route is not None:
            if self.job_type == "opt":
                route_string += (
                    f" opt=({self.additional_opt_options_in_route})"
                )
            elif self.job_type == "ts":
                if "calcall" not in self.additional_opt_options_in_route:
                    route_string += f" opt=(ts,calcfc,noeigentest,{self.additional_opt_options_in_route})"
                else:
                    route_string += f" opt=(ts,noeigentest,{self.additional_opt_options_in_route})"
            elif self.job_type == "modredundant":
                route_string += f" opt=(modredundant,{self.additional_opt_options_in_route})"
                self.freq = True
            elif self.job_type == "scan":
                route_string += f" opt=(modredundant,{self.additional_opt_options_in_route})"
                self.freq = False
            elif self.job_type == "sp":
                route_string += ""
        elif self.additional_opt_options_in_route is None:
            if self.job_type == "opt":
                route_string += " opt"
            elif self.job_type == "ts":
                route_string += " opt=(ts,calcfc,noeigentest)"
            elif self.job_type == "modredundant":
                route_string += " opt=modredundant"
                self.freq = True
            elif self.job_type == "scan":
                route_string += " opt=modredundant"
                self.freq = False
            elif self.job_type == "sp":
                route_string += ""

        # write frequency
        if self.freq and not self.numfreq:
            route_string += " freq"
        elif not self.freq and self.numfreq:
            route_string += " freq=numer"

        # write functional and basis
        if self.basis is None:
            raise ValueError("Warning: Basis is missing!")
        if self.ab_initio is not None and self.functional is None:
            method = self.ab_initio
        elif self.ab_initio is None and self.functional is not None:
            method = self.functional
        elif self.ab_initio is not None and self.functional is not None:
            raise ValueError(
                "Warning: Both ab initio and DFT functional are provided!"
            )
        else:
            raise ValueError(
                "Warning: Both ab initio and DFT functional are missing!"
            )

        if "gen" in self.basis:
            genecp_section = self.get_genecp_section(molecule=atoms)
            route_string += f" {method} {genecp_section.genecp_type}"
        else:
            route_string += f" {method} {self.basis}"

        # write forces calculation
        if self.forces:
            route_string += " force"

        if self.custom_solvent is not None:
            if self.solvent_model is None and self.solvent_id is None:
                route_string += (
                    " scrf=(pcm,read)"  # using pcm model as default
                )
            else:
                # Set default values if any of solvent_model or solvent_id are None
                solvent_model = self.solvent_model or "pcm"
                solvent_id = self.solvent_id or "generic,read"
                route_string += f" scrf=({solvent_model},solvent={solvent_id})"
        elif (
            self.solvent_model is not None and self.solvent_id is not None
        ):  # solvation is turned on
            route_string += (
                f" scrf=({self.solvent_model},solvent={self.solvent_id})"
            )
        elif (self.solvent_model is not None and self.solvent_id is None) or (
            self.solvent_model is None and self.solvent_id is not None
        ):  # if one is provided but the other not
            raise ValueError(
                f"Both solvent model need to be specified. \nCurrently, solvent model is {self.solvent_model} "
                f"and solvent id is {self.solvent_id}!"
            )

        # write additional parameters for route
        if self.additional_route_parameters is not None:
            route_string += f" {self.additional_route_parameters}"

        # write job type specific route
        if self.job_type == "nci":
            route_string += " output=wfn"  # output wavefunction file for NCI
        elif self.job_type == "wbi":
            route_string += " pop=nboread"  # write bond order matrix
        return route_string

    def _write_gaussian_title(self, f, job_label):
        if self.title is not None:
            f.write(f"{self.title}\n")
        else:
            # write default title
            f.write(f"Gaussian job: {job_label}\n")
        f.write("\n")

    def _write_charge_and_multiplicity(self, f):
        if self.charge is None or self.multiplicity is None:
            raise TypeError(
                f"Charge is {self.charge} and Multiplicity is {self.multiplicity}"
            )
        f.write(f"{self.charge} {self.multiplicity}\n")

    def _write_pbc(self, f, atoms):
        if any(atoms.pbc):
            pbc_vectors = atoms.cell[:]
            for i in range(3):  # 3D PBC vectors
                if not all(pbc_vectors[i] == [0.0, 0.0, 0.0]):
                    string = "{:5} {:15.10f} {:15.10f} {:15.10f}\n".format(
                        "TV",
                        float(pbc_vectors[i][0]),
                        float(pbc_vectors[i][1]),
                        float(pbc_vectors[i][2]),
                    )
                    f.write(string)
        f.write("\n")

    def _write_link_section(self, f, atoms, num_cores, mem_gigs, job_label):
        # subclass can implement
        pass

    def _write_cartesian_coordinates(self, f, atoms):
        assert atoms is not None, "No molecular geometry found!"
        coordinates = ""
        freeze_atom_indices = atoms.fixed_atoms_indices()

        for i, (s, (x, y, z)) in enumerate(
            zip(atoms.symbols, atoms.positions, strict=False)
        ):
            if len(freeze_atom_indices) == 0:
                # No frozen indices
                string = f"{s:5} {float(x):15.10f} {float(y):15.10f} {float(z):15.10f}\n"
            elif i in freeze_atom_indices:
                # Some frozen indices and i in list of frozen indices
                string = f"{s:5}    -1    {float(x):15.10f} {float(y):15.10f} {float(z):15.10f}\n"
            else:
                # Some frozen indices and i not in list of frozen indices
                string = f"{s:5}     0    {float(x):15.10f} {float(y):15.10f} {float(z):15.10f}\n"
            coordinates += string
        f.write(coordinates)

    def _append_modredundant(self, f):
        if self.modredundant:
            if isinstance(self.modredundant, list):
                # append for modredundant jobs
                # 'self.modredundant' as list of lists, or a single list if only one fixed constraint
                prepend_string_list = (
                    get_prepend_string_list_from_modred_free_format(
                        input_modred=self.modredundant
                    )
                )
                for prepend_string in prepend_string_list:
                    f.write(f"{prepend_string} F\n")

            elif isinstance(self.modredundant, dict):
                # append for scanning job
                # self.modredundant = {'num_steps': 10, 'step_size': 0.05, 'coords': [[1,2], [3,4]]}
                coords_list = self.modredundant["coords"]
                prepend_string_list = (
                    get_prepend_string_list_from_modred_free_format(
                        input_modred=coords_list
                    )
                )
                for prepend_string in prepend_string_list:
                    f.write(
                        f"{prepend_string} S {self.modredundant['num_steps']} {self.modredundant['step_size']}\n"
                    )
            f.write("\n")

    def _append_gen_genecp_basis(self, f, atoms):
        if self._genecp_elements_specified or self._genecp_file_specified:
            genecp_section = self.get_genecp_section(molecule=atoms)
            genecp_string = genecp_section.string
            f.write(genecp_string)
            f.write("\n")

    @property
    def _genecp_elements_specified(self):
        return (
            self.heavy_elements is not None
            and self.heavy_elements_basis is not None
        )

    @property
    def _genecp_file_specified(self):
        return self.gen_genecp_file is not None and os.path.exists(
            self.gen_genecp_file
        )

    def get_genecp_section(self, molecule):
        if self._genecp_elements_specified:
            logger.info(
                f"GENECP elements specified:\n"
                f"Heavy elements: {self.heavy_elements}\n"
                f"Heavy elements basis: {self.heavy_elements_basis}\n"
                f"Light elements basis: {self.light_elements_basis}\n"
            )
            # Method 1 for getting genecp
            # Need to supply self.heavy_elements, self.heavy_elements_basis and self.light_elements_basis
            heavy_elements_in_structure = self.prune_heavy_elements(molecule)

            genecp_section = GenGenECPSection.from_bse_api(
                light_elements=self.get_light_elements(molecule),
                light_elements_basis=self.light_elements_basis,
                heavy_elements=heavy_elements_in_structure,
                heavy_elements_basis=self.heavy_elements_basis,
            )

        elif self._genecp_file_specified:
            logger.info(f"GENECP file specified: {self.gen_genecp_file}")
            # Method 2 for getting genecp:
            # Supplied path to genecp file
            genecp_section = GenGenECPSection.from_genecp_path(
                genecp_path=self.gen_genecp_file
            )
        else:
            raise ValueError("Could not get GenECPSection")
        return genecp_section

    def prune_heavy_elements(self, atoms):
        # heavy atoms list supplied from settings contains all heavy atoms needed for heavy_atom_basis but in each
        # structure, some heave atoms supplied from settings may not appear in the structure
        return list(set(atoms.symbols).intersection(self.heavy_elements))

    def get_light_elements(self, atoms):
        if self.heavy_elements is None:
            return []

        unique_atoms = set(atoms.symbols)
        light_elements_set = unique_atoms - set(self.heavy_elements)
        light_elements_list = list(light_elements_set)
        from pyatoms.utils.periodictable import (
            sort_list_of_elements_according_to_atomic_number,
        )

        sorted_light_elements_list = (
            sort_list_of_elements_according_to_atomic_number(
                light_elements_list
            )
        )
        logger.info(
            f"Light elements in structure: {sorted_light_elements_list}"
        )
        return sorted_light_elements_list

    def set_custom_solvent_via_file(self, filename):
        if not os.path.exists(os.path.expanduser(filename)):
            raise ValueError(f"File {filename} does not exist!")

        # path to the file for custom_solvent parameters
        with open(filename) as f:
            lines = f.readlines()

        lines = [line.strip() for line in lines]

        self.custom_solvent = "\n".join(lines)

    def _append_custom_solvent_parameters(self, f):
        if self.custom_solvent is None:
            return

        # ensures that the solvent parameters can be supplied in free string format
        line_elem = self.custom_solvent.strip().split("\n")
        for line in line_elem:
            f.write(f"{line}\n")
        f.write("\n")

    def _append_job_specific_info(self, f, job_label):
        if self.job_type == "nci":
            # appending for nci job
            f.write(f"{job_label}.wfn\n")
            f.write("\n")
        elif self.job_type == "wbi":
            # appending for wbi job
            f.write("$nbo bndidx $end\n")
            f.write("\n")
        elif self.job_type == "resp":
            # appending for resp job
            f.write(f"{job_label}.gesp\n")
            f.write("\n")

    def _append_other_additional_info(self, f):
        # append content of a supplied text file or text (as in append custom solvent)
        if not self.append_additional_info:
            return

        if isinstance(self.append_additional_info, str) and os.path.exists(
            os.path.expanduser(self.append_additional_info)
        ):
            # path to the file for additional append info
            with open(self.append_additional_info) as g:
                for line in g.readlines():
                    f.write(line)
        else:
            # ensures that the additional append info can be supplied in free string format
            line_elem = self.append_additional_info.strip().split("\n")
            for line in line_elem:
                f.write(f"{line}\n")
        f.write("\n")

    def remove_solvent(self):
        self.solvent_model = None
        self.solvent_id = None

    def update_solvent(self, solvent_model=None, solvent_id=None):
        """Update solvent model and solvent identity for implicit solvation.

        Solvent models available: ['pcm', 'iefpcm', 'cpcm', 'smd', 'dipole', 'ipcm', 'scipcm'].
        """
        # update only if not None; do not update to default value of None
        if solvent_model is not None:
            if solvent_model.lower() not in gaussian_solvation_models:
                raise ValueError(
                    f"The specified solvent model {solvent_model} is not in \n"
                    f"the available solvent models: {gaussian_solvation_models}"
                )

            self.solvent_model = solvent_model

        if solvent_id is not None:
            self.solvent_id = solvent_id

    def modify_solvent(self, remove_solvent=False, **kwargs):
        if not remove_solvent:
            self.update_solvent(**kwargs)
        else:
            self.remove_solvent()

    def apply_on(self, job, jobrunner):
        # TODO: what are the exact roles of apply_on?
        # pass
        # jobrunner is the OverallJobRunner instead of job specific jobrunner
        # specific_runner = jobrunner.create_specific_runner(job)
        # specific_runner._prerun(job)
        # assert os.path.exists(specific_runner.job_inputfile), f'Inputfile {specific_runner.job_inputfile}
        # is not found!'

        if (
            jobrunner.scratch
            and jobrunner.scratch_dir is not None
            and os.path.exists(jobrunner.scratch_dir)
        ):
            job_scratch_dir = os.path.join(jobrunner.scratch_dir, job.label)
            with suppress(FileExistsError):
                os.mkdir(job_scratch_dir)
                logger.info(f"Folder in scratch {job_scratch_dir} is made.")
            self.write_gaussian_input_from_job(
                output_dir=job_scratch_dir, job=job, jobrunner=jobrunner
            )
            scratch_inputfile = os.path.join(
                job_scratch_dir, f"{job.label}.com"
            )
            assert os.path.exists(
                scratch_inputfile
            ), f"inputfile {scratch_inputfile} is not found"
        elif jobrunner.scratch and not os.path.exists(jobrunner.scratch_dir):
            logger.info(
                f"{jobrunner.scratch_dir} does not exist! Running job in {job.folder}."
            )
            self.write_gaussian_input_from_job(
                output_dir=job.folder, job=job, jobrunner=jobrunner
            )
            inputfilename = os.path.basename(
                job.inputfile
            )  # job.inputfile is the full path to the inputfile
            runfolder_inputfile = os.path.join(job.folder, inputfilename)
            assert os.path.exists(
                runfolder_inputfile
            ), f"inputfile {runfolder_inputfile} is not found"
        else:
            logger.info(f"Running job in {job.folder}.")
            self.write_gaussian_input_from_job(
                output_dir=job.folder, job=job, jobrunner=jobrunner
            )
            inputfilename = os.path.basename(
                job.inputfile
            )  # job.inputfile is the full path to the inputfile
            runfolder_inputfile = os.path.join(job.folder, inputfilename)
            assert os.path.exists(
                runfolder_inputfile
            ), f"inputfile {runfolder_inputfile} is not found"

    @classmethod
    def from_user_yaml(cls, filename, **kwargs):
        config = read_molecular_job_yaml(filename)
        return cls.from_user_config(config, **kwargs)

    @classmethod
    def from_user_config(cls, config, job_type):
        """Generate GaussianJobSettings from a master dict containing all the settings for each job type config."""
        return cls(**config[job_type])

    @classmethod
    def from_dict(cls, settings_dict):
        return cls(**settings_dict)


class GaussianIRCJobSettings(GaussianJobSettings):
    def __init__(
        self,
        predictor=None,
        recorrect=None,
        recalc_step=6,
        direction=None,
        maxpoints=512,
        maxcycles=128,
        stepsize=20,
        flat_irc=False,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.predictor = predictor
        self.recorrect = recorrect
        self.recalc_step = recalc_step
        self.direction = direction
        self.maxpoints = maxpoints
        self.maxcycles = maxcycles
        self.stepsize = stepsize
        self.flat_irc = flat_irc
        self.freq = False  # turn off freq calc for IRC jobs
        self.forces = False  # turn off forces calculations
        self.route_to_be_written = None

    def _write_route_section_default(self, f, atoms):
        route_string = self._get_route_string_from_jobtype(atoms=atoms)

        # if flat irc
        if self.flat_irc:
            self.predictor = "LQA"
            self.recorrect = "never"
            self.recalc_step = -5

        # write job type specific route for irc
        if self.job_type == "ircf":
            self.direction = "forward"
        elif self.job_type == "ircr":
            self.direction = "reverse"

        if self.predictor is not None and self.recorrect is not None:
            route_string += (
                f" irc({self.predictor},calcfc,recorrect={self.recorrect},recalc={self.recalc_step},"
                f"stepsize={self.stepsize},{self.direction},maxpoints={self.maxpoints},maxcycle={self.maxcycles})"
            )
        elif self.predictor is None and self.recorrect is None:
            route_string += (
                f" irc(calcfc,recalc={self.recalc_step},{self.direction},"
                f"maxpoints={self.maxpoints},maxcycle={self.maxcycles})"
            )
        else:
            raise ValueError(
                f"Only one of predictor type and recorrect is specified, please check!\n"
                f"Predictor: {self.predictor}; Recorrect: {self.recorrect}"
            )

        if self.additional_route_parameters is not None:
            route_string += f" {self.additional_route_parameters}"

        f.write(route_string + "\n")
        f.write("\n")


class GaussianLinkJobSettings(GaussianJobSettings):
    def __init__(
        self, link=True, link_route=None, stable="opt", guess="mix", **kwargs
    ):
        super().__init__(**kwargs)
        self.link = link
        self.link_route = link_route
        self.stable = stable
        self.guess = guess

    @property
    def link_route_string(self):
        if self.link_route is not None:
            link_route_string = self.link_route
            if "geom=check" not in self.link_route:
                link_route_string += " geom=check"
            if "guess=read" not in self.link_route:
                link_route_string += " guess=read"
            return link_route_string
        return self._get_link_route_string_from_jobtype()

    def _get_link_route_string_from_jobtype(self):
        route_string = super()._get_route_string_from_jobtype()
        # remove "opt or opt= and freq" from route string
        pattern = re.compile(r"\s*opt\s*(=\s*(\(.*\)|\w+))?\s*", re.IGNORECASE)
        route_string_final = re.sub(pattern, "", route_string)
        route_string_final = route_string_final.replace("freq", "")

        if self.stable is not None and self.guess is not None:
            route_string_final += f" stable={self.stable} guess={self.guess}"
        route_string_final += " geom=check guess=read "
        return route_string_final

    def _write_link_section(self, f, atoms, num_cores, mem_gigs, job_label):
        # get route string from job type
        route_string = self._get_route_string_from_jobtype(atoms=atoms)
        route_string += " geom=check guess=read "
        f.write("--Link1--\n")
        self._write_gaussian_header(f, num_cores, mem_gigs, job_label)
        f.write(f"{route_string}\n")
        f.write("\n")
        self._write_gaussian_title(f, job_label)
        self._write_charge_and_multiplicity(f)
        f.write("\n")
        self._append_modredundant(f)  # write modredundant parameters
        self._append_gen_genecp_basis(f, atoms)  # then write genecp info
        self._append_custom_solvent_parameters(
            f
        )  # followed by user defined solvennt parameters
        self._append_job_specific_info(f, job_label)
        self._append_other_additional_info(f)


class GaussianTDDFTJobSettings(GaussianJobSettings):
    def __init__(
        self, states="singlets", root=1, nstates=3, eqsolv=None, **kwargs
    ):
        super().__init__(**kwargs)
        self.states = states
        self.root = root
        self.nstates = nstates
        self.eqsolv = eqsolv

    def _get_route_string_from_jobtype(self):
        route_string = super()._get_route_string_from_jobtype()

        if self.eqsolv is None:
            eqsolv = ""
        else:
            eqsolv_options = ["eqsolv", "noneqsolv"]
            assert (
                self.eqsolv.lower() in eqsolv_options
            ), f"Possible equilibrium solvation options are: {eqsolv_options}!"
            eqsolv = f",{self.eqsolv}"

        route_string += f" TD({self.states},nstates={self.nstates},root={self.root}{eqsolv})"

        return route_string
